/************************************************************************/
/* This file is part of openMask(c) INRIA, CNRS, Universite de Rennes 1 */
/* 1993-2002, thereinafter the Software                                 */
/*                                                                      */
/* The Software has been developped within the Siames Project.          */
/* INRIA, the University of Rennes 1 and CNRS jointly hold intellectual */
/* property rights                                                      */
/*                                                                      */
/* The Software has been registered with the Agence pour la Protection  */
/* des Programmes (APP) under registration number                       */
/* IDDN.FR.001.510008.00.S.P.2001.000.41200                             */
/*                                                                      */
/* This file may be distributed under the terms of the Q Public License */
/* version 1.0 as defined by Trolltech AS of Norway and appearing in    */
/* the file LICENSE.QPL included in the packaging of this file.         */
/*                                                                      */
/* Licensees holding valid specific licenses issued by INRIA, CNRS or   */
/* Universite Rennes 1 for the software may use this file in            */
/* acordance with that specific license                                 */
/************************************************************************/
/************************************************************************/
/* WARNING : GENERATED FILE. DO NOT MODIFY IT.                          */
/* Generated the 2006-09-12 at 18:00:28                                 */
/* Generated by omk version 1.2.0                                       */
/* Use just as it is or derive this class to add the  necessary         */
/* functions.                                                           */
/************************************************************************/
/************************************************************************/

#if !defined _SIMULATED_OBJECTS_OVKPSSIMULATEDBOXBASE_H_
#define _SIMULATED_OBJECTS_OVKPSSIMULATEDBOXBASE_H_

#include <OMKExtensibleSimulatedObject.h>
#include <OMKValuedEventListenerCallBack.h>
#include <OMKEventListenerCallBack.h>
#include <OMKSystemEventIdentifier.h>
#include "ovkEventId.h"
#include "ovkPsTypeChunk.h"

/** \brief Class \ref CSimulatedBoxBase generated.
 * \date generated the 2006-09-12 at 18:00:28
 * \author Yann Renard (INRIA/IRISA)
 * @description
 * This class is generated. \n
 * Use it by derivation to add the necessary methods.\n
 * This base class is never implemented, only the derivate classes (like \ref OMKSimulatedBox) are.\n
 * All the members of this class are protected except the destructor according to the OpenMASK precepts.\n
 * @configurationParameters
 * \n \b Connection \b parameters \b for \b events \n
 * The following connection parameters are optional, they are used to listen signals.
 * \li \b ListenOpenViBEDataUpdate a boolean, \e false by default, it tells if the 
 * signal "OpenViBEDataUpdate" is listened (\e true) or not (\e false).
 * \li \b ListenOpenViBEDataUpdateBy a array of object names, the signal 
 * "OpenViBEDataUpdate" which emitted by those objects will be listened.
 * \li \b ListenOpenViBESetBoxPrototype a boolean, \e false by default, it tells if the 
 * signal "OpenViBESetBoxPrototype" is listened (\e true) or not (\e false).
 * \li \b ListenOpenViBESetBoxPrototypeBy a array of object names, the signal 
 * "OpenViBESetBoxPrototype" which emitted by those objects will be listened.
 *
 * \n \b Configuration \b example
 * \code
 myObject
 {
   Class OMKSimulatedBox
   Scheduling
   {
     Frequency 75
     Process processA
   }
   UserParams
   {
     // Optional parameters
     ListenOpenViBEDataUpdate false
     ListenOpenViBEDataUpdateBy [ObjectName AnotherObjectName]
     ListenOpenViBESetBoxPrototype false
     ListenOpenViBESetBoxPrototypeBy [ObjectName AnotherObjectName]

 }
 * \endcode
 * \receivedEvents
 * \li \b OpenViBEDataUpdate:  a valued event by \e OpenViBE::Kernel::CTypeChunk.
 * This event is sent between the boxes in order so they can exchange buffer updates
 * \n To listen this signal add the following lines to your configuration
 * file. The first is to listen the signal from any object, the second is
 * to listen the signal from object named \e emittorObject.
 * \code
     ListenOpenViBEDataUpdate true
     ListenOpenViBEDataUpdateBy [emittorObject]
 * \endcode
 * \li \b OpenViBESetBoxPrototype:  a valued event by \e OMKTypeBoxPrototype.
 * This event is sent from the engine to configure each box' interface
 * \n To listen this signal add the following lines to your configuration
 * file. The first is to listen the signal from any object, the second is
 * to listen the signal from object named \e emittorObject.
 * \code
     ListenOpenViBESetBoxPrototype true
     ListenOpenViBESetBoxPrototypeBy [emittorObject]
 * \endcode
 */
namespace OpenViBE {
namespace Kernel {
class CSimulatedBoxBase : public OMK::ExtensibleSimulatedObject
{
public:

	/// @name Constructors and destructor.
	//@{
	/// \brief Destructor of \ref CSimulatedBoxBase.
	virtual ~CSimulatedBoxBase() ;

protected:

	/// \brief Protected constructor of \ref CSimulatedBoxBase call by derivate classes (\ref OMKSimulatedBox).
	CSimulatedBoxBase( OMK::Controller& ctrl, const OMK::ObjectDescriptor& objectDescriptor );
	//@}

	/// @name Reset and loaders
	//@{
	/// \brief Reset the default values of \ref CSimulatedBoxBase.
	///
	/// No data or output have been declared, this method does nothing.
	virtual void resetDefaultValues();
	/// \brief Configuration parameters loader of \ref CSimulatedBoxBase.
	/// \param[in] node the root node of the configuration parameter.
	/// \return true if all \e needed parameters can be read.
	///
	/// Reads in the configuration node the values to set the attributs.
	/// No data or output have been declared, this method does nothing.
	virtual bool loadAttributsParameters( const OMK::ConfigurationParameterDescriptor * node );
	/// \brief Configuration parameters loader of \ref CSimulatedBoxBase.
	/// \param[in] node the root node of the configuration parameter.
	/// \return true if all the inputs are well connected.
	///
	/// Reads in the configuration node the values to connect the inputs.
	/// No input has been declared, this method does nothing.
	virtual bool loadInputsConnectionsParameters( const OMK::ConfigurationParameterDescriptor * node ) { return node!=NULL ; }
	/// \brief Configuration parameters loader of \ref CSimulatedBoxBase.
	/// \param[in] node the root node of the configuration parameter.
	/// \return true if all the events are well connected to a signal.
	///
	/// Creates events listeners and associates them to their callback method.\n
	/// Reads in the configuration node the values to register signals.
	virtual bool loadEventsConnectionsParameters( const OMK::ConfigurationParameterDescriptor * node ) ;
	//@}

	/// @name OMK::SimulatedObject interfaces
	//@{
	/// \brief Init method inherited from OMKSimulatedObject.
	///
	/// Calls the loaders.\n
	/// Most of the time it is not necessary to redefine this method in the children
	/// class. If you have to add some initialisations, redefine and call the
	/// inherited method to load parameters or call directly the loaders.
	virtual void init() ;
	/// \brief Compute method inherited from OMK::SimulatedObject.
	///
	/// The \ref compute method is splitted in three parts: the first reads the
	/// inputs, the second computes the new values for the parameters, the last
	/// one sets the outputs from their associated parmeters.\n
	/// In the children class, the second method must be defined, and most of
	/// the time you do not have to change the others.\n
	virtual void compute() ;
	/// \brief This part of the \ref compute methods reads the inputs.
	///
	/// No input has been declared, nothing to do in this method.
	virtual void computeInputs() {}
	/// \brief This part of the \ref compute methods computes the parameters.
	///
	/// The inputs and outputs works with associated data, you should use their associated data.\n
	/// It is a pure virtual method, so it must be defined in the children.\n
	/// This method  updates nothing.
	virtual void computeParameters() = 0 ;
	/// \brief This part of the \ref compute methods copies the data in their associated output.
	///
	/// No output has been declared, nothing to do in this method.
	virtual void computeOutputs() {}
	//@}

protected:

	/// @name Call back methods and listeners for events processing.
	//@{
	/// \brief Call back to process the "OpenViBEDataUpdate" event
	/// \return see \ref OMK::ValuedEventListenerCallBack::CallBackFct
	virtual bool processOpenViBEDataUpdateEvent( OMK::ValuedEvent< OpenViBE::Kernel::CTypeChunk > *e ) ;
	/// \brief Call back to process the "MaskStart" event
	/// \return see \ref OMK::EventListenerCallBack::CallBackFct
	virtual bool processMaskStartEvent( OMK::Event *e ) ;
	/// \brief Call back to process the "MaskStop" event
	/// \return see \ref OMKEventListenerCallBack::CallBackFct
	virtual bool processMaskStopEvent( OMK::Event *e ) ;

	/// \brief Event listener to listen the "OpenViBEDataUpdate" event.
	///
	/// The event listener is created in the \ref init method.\n
	/// Use registration methods \ref registerForOpenViBEDataUpdateSignal and
	/// registerForOpenViBEDataUpdateSignalBy to listen the signal.
	OMK::ValuedEventListenerCallBack< OpenViBE::Kernel::CSimulatedBoxBase, OpenViBE::Kernel::CTypeChunk > *_openViBEDataUpdateEventListener ;
	/// \brief Event listener to listen the "MaskStart" event.
	///
	/// The event listener is created in the \ref init method.\n
	/// Use registration methods \ref registerForMaskStartSignal and
	/// registerForMaskStartSignalBy to listen the signal.
	OMK::EventListenerCallBack< OpenViBE::Kernel::CSimulatedBoxBase > *_maskStartEventListener ;
	/// \brief Event listener to listen the "MaskStop" event.
	///
	/// The event listener is created in the \ref init method.\n
	/// Use registration methods \ref registerForMaskStopSignal and
	/// registerForMaskStopSignalBy to listen the signal.
	OMK::EventListenerCallBack< OpenViBE::Kernel::CSimulatedBoxBase > *_maskStopEventListener ;
	//@}

	/// @name Registering signals.
	//@{
	/// \brief Register listening of the "OpenViBEDataUpdate" signal comming from any object.
	/// \return true if the registering is ok
	bool registerForOpenViBEDataUpdateSignal() { return registerForSignal( EventId::s_openViBEDataUpdate ) ; }
	/// \brief Listening cancel of the "OpenViBEDataUpdate" signal from any object
	/// previously registered with \ref registerForOpenViBEDataUpdateSignal.
	/// \return true if the canceling is ok
	bool cancelRegistrationForOpenViBEDataUpdateSignal() { return cancelRegistrationForSignal( EventId::s_openViBEDataUpdate ) ; }
	/// \brief Register listening of the "OpenViBEDataUpdate" signal comming from specified object.
	/// \param[in] producer the object to listen
	/// \return true if the registering is ok
	bool registerForOpenViBEDataUpdateSignalBy( const OMK::Name &producer ) { return registerForSignalBy( EventId::s_openViBEDataUpdate, producer  ) ; }
	/// \brief Listening cancel of the "OpenViBEDataUpdate" signal from specified object
	/// previously registered with \ref registerForOpenViBEDataUpdateSignalBy.
	/// \param[in] producer the listened object to cancel from.
	/// \return true if the canceling is ok
	bool cancelRegistrationForOpenViBEDataUpdateSignalBy( const OMK::Name &producer ) { return cancelRegistrationForSignalBy( EventId::s_openViBEDataUpdate, producer ) ; }

	/// \brief Register listening of the "MaskStart" signal comming from any object.
	/// \return true if the registering is ok
	bool registerForMaskStartSignal() { return registerForSignal( OMK::SystemEventIdentifier::MaskStart ) ; }
	/// \brief Listening cancel of the "MaskStart" signal from any object
	/// previously registered with \ref registerForMaskStartSignal.
	/// \return true if the canceling is ok
	bool cancelRegistrationForMaskStartSignal() { return cancelRegistrationForSignal( OMK::SystemEventIdentifier::MaskStart ) ; }
	/// \brief Register listening of the "MaskStart" signal comming from specified object.
	/// \param[in] producer the object to listen
	/// \return true if the registering is ok
	bool registerForMaskStartSignalBy( const OMK::Name &producer ) { return registerForSignalBy( OMK::SystemEventIdentifier::MaskStart, producer  ) ; }
	/// \brief Listening cancel of the "MaskStart" signal from specified object
	/// previously registered with \ref registerForMaskStartSignalBy.
	/// \param[in] producer the listened object to cancel from.
	/// \return true if the canceling is ok
	bool cancelRegistrationForMaskStartSignalBy( const OMK::Name &producer ) { return cancelRegistrationForSignalBy( OMK::SystemEventIdentifier::MaskStart, producer ) ; }

	/// \brief Register listening of the "MaskStop" signal comming from any object.
	/// \return true if the registering is ok
	bool registerForMaskStopSignal() { return registerForSignal( OMK::SystemEventIdentifier::MaskStop ) ; }
	/// \brief Listening cancel of the "MaskStop" signal from any object
	/// previously registered with \ref registerForMaskStopSignal.
	/// \return true if the canceling is ok
	bool cancelRegistrationForMaskStopSignal() { return cancelRegistrationForSignal( OMK::SystemEventIdentifier::MaskStop ) ; }
	/// \brief Register listening of the "MaskStop" signal comming from specified object.
	/// \param[in] producer the object to listen
	/// \return true if the registering is ok
	bool registerForMaskStopSignalBy( const OMK::Name &producer ) { return registerForSignalBy( OMK::SystemEventIdentifier::MaskStop, producer  ) ; }
	/// \brief Listening cancel of the "MaskStop" signal from specified object
	/// previously registered with \ref registerForMaskStopSignalBy.
	/// \param[in] producer the listened object to cancel from.
	/// \return true if the canceling is ok
	bool cancelRegistrationForMaskStopSignalBy( const OMK::Name &producer ) { return cancelRegistrationForSignalBy( OMK::SystemEventIdentifier::MaskStop, producer ) ; }
	//@}

	/// @name Methods to emit event and signal.
	//@{
	/// \brief Sends the "OpenViBEDataUpdate" event to a specific object
	/// \param[in] receiver the name of the receiver object
	/// \param[in] value the value associated to the event
	void sendOpenViBEDataUpdateEvent( const OMK::Name &receiver, const OpenViBE::Kernel::CTypeChunk & value )
	{
#if 0
		// $$$$$$$$$$$$$$$$$$$
		OMK::ValuedEvent<OpenViBE::Kernel::CTypeChunk>* l_pEvent=
			new OMK::ValuedEvent<OpenViBE::Kernel::CTypeChunk>(
				EventId::s_openViBEDataUpdate,
				getSimulatedDate()+10001,
				getName(),
				receiver,
				value);
		sendEvent(l_pEvent);
#endif
#if 0
		sendValuedEventASAP( receiver, EventId::s_openViBEDataUpdate, value ) ;
#endif
#if 1
		sendValuedEvent( receiver, EventId::s_openViBEDataUpdate, value ) ;
#endif
	}
	/// \brief Sends the "OpenViBEDataUpdate" signal.
	/// \param[in] value the value associated to the signal
	void fireOpenViBEDataUpdateEvent( const OpenViBE::Kernel::CTypeChunk & value )
	{ fireValuedSignal( EventId::s_openViBEDataUpdate, value ) ; }
	//@}

protected:

	///Flag to know how to handle error during init.
	bool _exitOnInitError ;
	/// @name Data
	//@{

	//@}
	/// @name Inputs, outputs and configuration parameters
	/// The derivated classes must uses the data
	//@{
	//@}
};
};
};

#endif // defined _SIMULATED_OBJECTS_OVKPSSIMULATEDBOXBASE_H_
