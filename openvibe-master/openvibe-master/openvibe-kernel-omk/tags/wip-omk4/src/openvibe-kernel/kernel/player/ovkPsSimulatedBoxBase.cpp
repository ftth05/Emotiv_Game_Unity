
/************************************************************************/
/* This file is part of openMask(c) INRIA, CNRS, Universite de Rennes 1 */
/* 1993-2002, thereinafter the Software                                 */
/*                                                                      */
/* The Software has been developped within the Siames Project.          */
/* INRIA, the University of Rennes 1 and CNRS jointly hold intellectual */
/* property rights                                                      */
/*                                                                      */
/* The Software has been registered with the Agence pour la Protection  */
/* des Programmes (APP) under registration number                       */
/* IDDN.FR.001.510008.00.S.P.2001.000.41200                             */
/*                                                                      */
/* This file may be distributed under the terms of the Q Public License */
/* version 1.0 as defined by Trolltech AS of Norway and appearing in    */
/* the file LICENSE.QPL included in the packaging of this file.         */
/*                                                                      */
/* Licensees holding valid specific licenses issued by INRIA, CNRS or   */
/* Universite Rennes 1 for the software may use this file in            */
/* acordance with that specific license                                 */
/************************************************************************/
/************************************************************************/
/* WARNING : GENERATED FILE. DO NOT MODIFY IT.                          */
/* Generated the 2006-09-12 at 18:00:28                                 */
/* Generated by omk version 1.2.0                                       */
/* Use just as it is or derive this class to add the  necessary         */
/* functions.                                                           */
/************************************************************************/
/************************************************************************/


#include "ovkPsSimulatedBoxBase.h"
#include <OMKParametersAccessor.h>
#include <vector>
#include <string>
#include <iostream>

using namespace OpenViBE;
using namespace OpenViBE::Kernel;

//========================================================================
// Default constructor
CSimulatedBoxBase::CSimulatedBoxBase( OMK::Controller& ctrl, const OMK::ObjectDescriptor& objectDescriptor )
: OMK::ExtensibleSimulatedObject( ctrl, objectDescriptor )
{
  _exitOnInitError = false ;
 }

//========================================================================
// Destructor
CSimulatedBoxBase::~CSimulatedBoxBase(void)
{
}
//========================================================================
// Default values for parameters
void CSimulatedBoxBase::resetDefaultValues()
{
  //=== Reset default parameters
  // No parameters to reset => Nothing to do
}
		//========================================================================
// Configuration parameters loader
bool CSimulatedBoxBase::loadAttributsParameters( const OMK::ConfigurationParameterDescriptor * node )
{
  // Tests the configuration parameter node
  if( !node )
  { // No valid node => display error message and return false
    std::cerr << ":-( Error in CSimulatedBoxBase::loadAttributsParameters for object \"" << getName().getString() << "\""
              << "\" (class " << getObjectDescriptor().getClass().getString() << ")"
              << std::endl << ">>> Invalid node" << std::endl ;
    return false ;
  }

  // No validation requiered, always true if valid node was given
  return true ;
}
		//========================================================================
// Creates events listeners and associates them to their callback method.
// Reads in the configuration node the values to register signals.
bool CSimulatedBoxBase::loadEventsConnectionsParameters( const OMK::ConfigurationParameterDescriptor * node )
{
  // the return value
  bool ok = true ;
	_openViBEDataUpdateEventListener = new OMK::ValuedEventListenerCallBack< CSimulatedBoxBase, CTypeChunk > ( *this, &CSimulatedBoxBase::processOpenViBEDataUpdateEvent, ::EventId::s_openViBEDataUpdate ) ;
  ok = _openViBEDataUpdateEventListener && ok ;
  _maskStartEventListener = new OMK::EventListenerCallBack< CSimulatedBoxBase > ( *this, &CSimulatedBoxBase::processMaskStartEvent, OMK::SystemEventIdentifier::MaskStart ) ;
  ok = _maskStartEventListener && ok ;
  _maskStopEventListener = new OMK::EventListenerCallBack< CSimulatedBoxBase > ( *this, &CSimulatedBoxBase::processMaskStopEvent, OMK::SystemEventIdentifier::MaskStop ) ;
  ok = _maskStopEventListener && ok ;
  // one or more listeners cannot be created => error
  if( !ok )
  {
    std::cerr << ":-( Error in CSimulatedBoxBase::loadEventsConnectionsParameters for object \"" << getName().getString() << "\" (class "
              << getObjectDescriptor().getClass().getString() << ")" << std::endl
              << ">>> One or more listeners cannot be created => Unable to initialize" << std::endl ;
    exit( -1 ) ;
  }

  // Tests the configuration parameter node
  ok = !node && ok ;

  // Temporary boolean to get the broadcast state
  bool listenSignal = true ;
  // Temporary name vector to get the listened object
  std::vector<std::string> listenedObjects ;

  // Reads parameters for signal "OpenViBEDataUpdate"
  // Gets the registration for the broadcast signal
  if( ok && OMK::ParametersAccessor::get( node, "ListenOpenViBEDataUpdate", listenSignal )
    && listenSignal )
    registerForOpenViBEDataUpdateSignal() ;
  // Gets the registration for listened objects
  listenedObjects.clear() ;
	if( ok && OMK::ParametersAccessor::get( node, "ListenOpenViBEDataUpdateBy", listenedObjects ) )
  {
    for( unsigned int i = 0 ; i < listenedObjects.size() ; i++ )
      registerForOpenViBEDataUpdateSignalBy( listenedObjects[ i ] ) ;
  }

  return ok ;
}
//========================================================================
// Initialisation
void CSimulatedBoxBase::init()
{
	const OMK::ConfigurationParameterDescriptor* node = getConfigurationParameters();
  // Test the configuration parameter node
  if( !node )
  {
    std::cerr << ":-( Error in CSimulatedBoxBase::init for object \"" << getName().getString() << "\" (class "
              << getObjectDescriptor().getClass().getString() << ")" << std::endl
              << ">>> Invalid node => Unable to initialize" << std::endl ;
    // Must exit or return
    if( _exitOnInitError ) exit( -1 ) ; else return ;
  }
  bool ok = true ;
  // Reset default parameters
  resetDefaultValues() ;
  // Load attributs
  ok = loadAttributsParameters  ( node ) && ok ;
  // Load connections
  ok = loadInputsConnectionsParameters( node ) && ok ;
  // Load connections
  ok = loadEventsConnectionsParameters( node ) && ok ;
  if( !ok && _exitOnInitError )
  { // Not ok, display the following message and exit
    std::cerr << ":-( Error in CSimulatedBoxBase::init for object \"" << getName().getString() << "\" (class "
              << getObjectDescriptor().getClass().getString() << ")" << std::endl
              << ">>> Unable to initialize the object" << std::endl ;
    exit( -1 ) ;
  }

	OMK::ExtensibleSimulatedObject::init();
}
//========================================================================
void CSimulatedBoxBase::compute()
{
  computeInputs    ();
  computeParameters();
  computeOutputs   ();
}

//========================================================================
//No need to call this method in the overwrite method of the sons
bool CSimulatedBoxBase::processOpenViBEDataUpdateEvent( OMK::ValuedEvent< CTypeChunk > *e )
{
  std::cerr << ":-( Warning in CSimulatedBoxBase:: processOpenViBEDataUpdateEvent for object \""
            << getName().getString() << "\" (class "
            << getObjectDescriptor().getClass().getString() << ")"
            << std::endl
            << ">>> Not yet implemented" << std::endl ;
  return true ;
}

//========================================================================
//No need to call this method in the overwrite method of the sons
bool CSimulatedBoxBase::processMaskStartEvent( OMK::Event *e )
{
  std::cerr << ":-( Warning in CSimulatedBoxBase:: processMaskStartEvent for object \""
            << getName().getString() << "\" (class "
            << getObjectDescriptor().getClass().getString() << ")"
            << std::endl
            << ">>> Not yet implemented" << std::endl ;
  return true ;
}

//========================================================================
//No need to call this method in the overwrite method of the sons
bool CSimulatedBoxBase::processMaskStopEvent( OMK::Event *e )
{
  std::cerr << ":-( Warning in CSimulatedBoxBase:: processMaskStopEvent for object \""
            << getName().getString() << "\" (class "
            << getObjectDescriptor().getClass().getString() << ")"
            << std::endl
            << ">>> Not yet implemented" << std::endl ;
  return true ;
}

//========================================================================
